#Chapter 6: Notes

## Recognizing C Code Constructs in Assembly

- **Code Constructs**
  - Code abstraction level that defines a functional property but not the details of its implementation.
  - Code constructs include loops, if statements, linked lists, switch statements, and so on.
  - Programs can be broken down into individual constructs that implement the overall functionality of the program.
  - Your goal as a malware analyst will be to go from disassembly to highlevel constructs.
  - Compiler versions and settings can impact how a particular construct appears in disassembly.
  - switch statements, function calls, and others can be compiled differently using different compilers.
  - Your goal is to understand the functionality of a program, not to analyze every single instruction.



## Global vs Local Variables.

- **Global Variables**
  - Can be accessed and used by any function in a program.
  - In assembly, global variables are referenced by memory addresses.
  - In the example below, the global variable ```x``` is signified by ```dword_40CF60```, a memory location at ```0x40CF60```.
  - Notice that ```x``` is changed in memory when eax is moved into ```dword_40CF60```.
  - All subsequent functions that utilize this variable will be impacted.

####Sample Global Variable Program

```
int x = 1;
int y = 2;

void main(){
  x = x+y;
  printf("Total = %d\n", x);
}
```

####Sample Global Variable Program Disassembly

```
00401003 mov eax, dword_40CF60
00401008 add eax, dword_40C000
0040100E mov dword_40CF60, eax
00401013 mov ecx, dword_40CF60
00401019 push ecx
0040101A push offset aTotalD ;"total = %d\n"
0040101F call printf
```


- **Local Variables**
  - Can be accessed only by the function in which they are defined.
  - In assembly, local variables are referenced by the stack addresses.
  - In the example below, , the local variable ```x``` is located on the stack at a constant offset relative to ebp.
  - Memory location ```[ebp-4]``` is used consistently throughout this function to reference the local variable ```x```.
  - This tells us that ```ebp-4``` is a stack-based local variable that is referenced only in the function in which it is defined.

####Sample Local Variable Program

```
void main(){
  int x = 1;
  int y = 2;

  x = x+y;
  printf("Total = %d\n", x);
}
```

####Sample Local Variable Program Disassembly

```
00401006 mov dword ptr [ebp-4], 0
0040100D mov dword ptr [ebp-8], 1
00401014 mov eax, [ebp-4]
00401017 add eax, [ebp-8]
0040101A mov [ebp-4], eax
0040101D mov ecx, [ebp-4]
00401020 push ecx
00401021 push offset aTotalD ; "total = %d\n"
00401026 call printf
```



## Disassembling Arithmetic Operations

####Sample Arithmetic Program

```
int a = 0;
int b = 1;
a = a + 11;
a = a - b;
a--;
b++;
b = a % 3;
```

####Sample Arithmetic Program Disassembly

```
00401006 mov [ebp+var_4], 0     ; int a = 0
0040100D mov [ebp+var_8], 1     ; int b = 1
00401014 mov eax, [ebp+var_4]   ; Put a into eax --,
00401017 add eax, 0Bh           ; Add 11 to eax    |--> a = a + 11
0040101A mov [ebp+var_4], eax   ; Put eax into a --'
0040101D mov ecx, [ebp+var_4]   ; Put a into ecx  -----,
00401020 sub ecx, [ebp+var_8]   ; Subtract b from ecx  |--> a = a - b
00401023 mov [ebp+var_4], ecx   ; Put ecx into a ------'
00401026 mov edx, [ebp+var_4]   ; Put a into edx ------,
00401029 sub edx, 1             ; Subtract 1 from edx  |--> a = a - 1  (a--)
0040102C mov [ebp+var_4], edx   ; Put edx into a ------'
0040102F mov eax, [ebp+var_8]   ; Put b into eax ----,
00401032 add eax, 1             ; Add 1 to eax       |--> b = b + 1  (b++)
00401035 mov [ebp+var_8], eax   ; Put eax into b ----'
00401038 mov eax, [ebp+var_4]   ; Put a into eax --------------,
0040103B cdq                    ; Extend eax to edx:eax        |
0040103C mov ecx, 3             ; Put 3 into ecx               |--> b = a % 3
00401041 idiv ecx               ; Divide edx:eax by ecx        |
00401043 mov [ebp+var_8], edx   ; Put edx (remainder) into b --'
```



## Recognizing if Statements

####Sample Conditional Program

```
int x = 1;
int y = 2;
if (x == y) {
  printf("x equals y.\n");
} else {
  printf("x is not equal to y.\n");
}
```

####Sample Conditional Program Disassembly

```
00401006     mov [ebp+var_8], 1            ; int y = 1;
0040100D     mov [ebp+var_4], 2            ; int x = 2;
00401014     mov eax, [ebp+var_8]          ; Put y into eax 
00401017     cmp eax, [ebp+var_4]          ; Check if x and eax are the same.
0040101A     jnz short loc_40102B          ; If y is not the same as eax, jump
0040101C     push offset aXEqualsY_        ; Put "x equals y.\n" on the stack
00401021     call printf                   ; Call printf, printing the value on the stack.
00401026     add esp, 4                    ; Add 4 to the stack pointer. (Bookkeeping)
00401029     jmp short loc_401038          ; Jump over the next block of code.
0040102B loc_40102B:                       ; 
0040102B     push offset aXIsNotEqualToY   ; Put "x is not equal to y.\n" on the stack
00401030     call printf                   ; Call printf, printing the value on the stack.
```



## Recognizing Nested if Statements

####Sample Nested Conditional Program

```
int x = 0;
int y = 1;
int z = 2;
  if(x == y){
    if(z==0){
      printf("z is zero and x = y.\n");
    }else{
      printf("z is non-zero and x = y.\n");
    }
  }else{
    if(z==0){
      printf("z zero and x != y.\n");
    }else{
      printf("z non-zero and x != y.\n");
  }
}
```

####Sample Nested Conditional Program Disassembly

```
00401006     mov [ebp+var_8], 0            ; int x = 0
0040100D     mov [ebp+var_4], 1            ; int y = 1
00401014     mov [ebp+var_C], 2            ; int z = 2
0040101B     mov eax, [ebp+var_8]          ; Put x in eax
0040101E     cmp eax, [ebp+var_4]          ; Compare y to eax
00401021     jnz short loc_401047          ; If they arent the same, jump to loc_401047
00401023     cmp [ebp+var_C], 0            ; Compare z to 0
00401027     jnz short loc_401038          ; If z is not the same as 0, jump to loc_401038
00401029     push offset aZIsZeroAndXY_    ; Push message  "z is zero and x = y.\n"
0040102E     call printf                   ; Print message "z is zero and x = y.\n"
00401033     add esp, 4                    ; Add 4 to the stack pointer. (Bookkeeping)
00401036     jmp short loc_401045          ; Jump to loc_401045
00401038 loc_401038:                       ; 
00401038     push offset aZIsNonZeroAndX   ; Push message  "z is non-zero and x = y.\n"
0040103D     call printf                   ; Print message "z is non-zero and x = y.\n"
00401042     add esp, 4                    ; Add 4 to the stack pointer. (Bookkeeping)
00401045 loc_401045:                       ; 
00401045     jmp short loc_401069          ; Jump to loc_401069
00401047 loc_401047:                       ; 
00401047     cmp [ebp+var_C], 0            ; Compare z to 0
0040104B     jnz short loc_40105C          ; If z is not the same as 0, jump to loc_40105C
0040104D     push offset aZZeroAndXY_      ; Push message  "z zero and x != y.\n"
00401052     call printf                   ; Print message "z zero and x != y.\n"
00401057     add esp, 4                    ; Add 4 to the stack pointer. (Bookkeeping)
0040105A     jmp short loc_401069          ; Jump to loc_401069
0040105C loc_40105C:                       ; 
0040105C     push offset aZNonZeroAndXY_   ; Push message  "z non-zero and x != y.\n"
00401061     call printf00401061           ; Print message "z non-zero and x != y.\n"
```



## Recognizing Loops

#### Sample for loop Program

```
int i;
for(i=0; i<100; i++) {
  printf("i equals %d\n", i);
}
```

#### Sample for loop Program Disassembly

```
00401004     mov [ebp+var_4], 0      ; int i = 0
0040100B     jmp short loc_401016    ; Jump to loc_401016
0040100D loc_40100D:                 ; 
0040100D     mov eax, [ebp+var_4]    ; Put i in eax
00401010     add eax, 1              ; Add 1 to eax
00401013     mov [ebp+var_4], eax    ; Put eax in i
00401016 loc_401016:                 ; 
00401016     cmp [ebp+var_4], 64h    ; Compare i to 64h (100)
0040101A     jge short loc_40102F    ; If i is greater than or equal to 100, jump to loc_40102F
0040101C     mov ecx, [ebp+var_4]    ; Put i in ecx
0040101F     push ecx                ; Push ecx onto the stack
00401020     push offset aID         ; Push message  "i equals %d\n"
00401025     call printf             ; Print message "i equals %d\n"
0040102A     add esp, 8              ; Add 4 to the stack pointer. (Bookkeeping)
0040102D     jmp short loc_40100D    ; Loop back to loc_40100D
```

#### Sample while loop Program

```
int status=0;
int result = 0;
while(status == 0){
  result = performAction();
  status = checkResult(result);
}
```

#### Sample while loop Program Disassembly

```
00401036     mov [ebp+var_4], 0      ; x = 0
0040103D     mov [ebp+var_8], 0      ; y = 0
00401044 loc_401044:                 ; 
00401044     cmp [ebp+var_4], 0      ; Compare x to 0
00401048     jnz short loc_401063    ; If x is not the same as 0, jump to loc_401063
0040104A     call performAction      ; Call the performAction function.
0040104F     mov [ebp+var_8], eax    ; Put eax in y.
00401052     mov eax, [ebp+var_8]    ; Put y in eax.
00401055     push eax                ; Push eax on the stack.
00401056     call checkResult        ; Call the checkResult function.
0040105B     add esp, 4              ; Add 4 to the stack pointer. (Bookkeeping).
0040105E     mov [ebp+var_4], eax    ; Put eax in x.
00401061     jmp short loc_401044`   ; Jump to loc_401044
```