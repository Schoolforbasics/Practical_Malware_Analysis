#Chapter 6: Notes

## Recognizing C Code Constructs in Assembly

- **Code Constructs**
  - Code abstraction level that defines a functional property but not the details of its implementation.
  - Code constructs include loops, if statements, linked lists, switch statements, and so on.
  - Programs can be broken down into individual constructs that implement the overall functionality of the program.
  - Your goal as a malware analyst will be to go from disassembly to highlevel constructs.
  - Compiler versions and settings can impact how a particular construct appears in disassembly.
  - switch statements, function calls, and others can be compiled differently using different compilers.
  - Your goal is to understand the functionality of a program, not to analyze every single instruction.



## Global vs Local Variables.

- **Global Variables**
  - Can be accessed and used by any function in a program.
  - In assembly, global variables are referenced by memory addresses.
  - In the example below, the global variable ```x``` is signified by ```dword_40CF60```, a memory location at ```0x40CF60```.
  - Notice that ```x``` is changed in memory when eax is moved into ```dword_40CF60```.
  - All subsequent functions that utilize this variable will be impacted.

####Sample Global Variable Program

```
int x = 1;
int y = 2;

void main(){
  x = x+y;
  printf("Total = %d\n", x);
}
```

####Sample Global Variable Program Disassembly

```
00401003 mov eax, dword_40CF60
00401008 add eax, dword_40C000
0040100E mov dword_40CF60, eax
00401013 mov ecx, dword_40CF60
00401019 push ecx
0040101A push offset aTotalD ;"total = %d\n"
0040101F call printf
```


- **Local Variables**
  - Can be accessed only by the function in which they are defined.
  - In assembly, local variables are referenced by the stack addresses.
  - In the example below, , the local variable ```x``` is located on the stack at a constant offset relative to ebp.
  - Memory location ```[ebp-4]``` is used consistently throughout this function to reference the local variable ```x```.
  - This tells us that ```ebp-4``` is a stack-based local variable that is referenced only in the function in which it is defined.

####Sample Local Variable Program

```
void main(){
  int x = 1;
  int y = 2;

  x = x+y;
  printf("Total = %d\n", x);
}
```

####Sample Local Variable Program Disassembly

```
00401006 mov dword ptr [ebp-4], 0
0040100D mov dword ptr [ebp-8], 1
00401014 mov eax, [ebp-4]
00401017 add eax, [ebp-8]
0040101A mov [ebp-4], eax
0040101D mov ecx, [ebp-4]
00401020 push ecx
00401021 push offset aTotalD ; "total = %d\n"
00401026 call printf
```



## Disassembling Arithmetic Operations

####Sample Arithmetic Program

```
int a = 0;
int b = 1;
a = a + 11;
a = a - b;
a--;
b++;
b = a % 3;
```

####Sample Arithmetic Program Disassembly

```
00401006 mov [ebp+var_4], 0     ; int a = 0
0040100D mov [ebp+var_8], 1     ; int b = 1
00401014 mov eax, [ebp+var_4]   ; Put a into eax --,
00401017 add eax, 0Bh           ; Add 11 to eax    |--> a = a + 11
0040101A mov [ebp+var_4], eax   ; Put eax into a --'
0040101D mov ecx, [ebp+var_4]   ; Put a into ecx  -----,
00401020 sub ecx, [ebp+var_8]   ; Subtract b from ecx  |--> a = a - b
00401023 mov [ebp+var_4], ecx   ; Put ecx into a ------'
00401026 mov edx, [ebp+var_4]   ; Put a into edx ------,
00401029 sub edx, 1             ; Subtract 1 from edx  |--> a = a - 1  (a--)
0040102C mov [ebp+var_4], edx   ; Put edx into a ------'
0040102F mov eax, [ebp+var_8]   ; Put b into eax ----,
00401032 add eax, 1             ; Add 1 to eax       |--> b = b + 1  (b++)
00401035 mov [ebp+var_8], eax   ; Put eax into b ----'
00401038 mov eax, [ebp+var_4]   ; Put a into eax --------------,
0040103B cdq                    ; Extend eax to edx:eax        |
0040103C mov ecx, 3             ; Put 3 into ecx               |--> b = a % 3
00401041 idiv ecx               ; Divide edx:eax by ecx        |
00401043 mov [ebp+var_8], edx   ; Put edx (remainder) into b --'
```



## Recognizing if Statements
